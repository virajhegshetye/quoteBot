// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { KnownPlaySourceType, KnownRecognizeInputType, CallAutomationApiClient, } from "./generated/src/index.js";
import { CallMediaImpl } from "./generated/src/operations/index.js";
import { createCommunicationAuthPolicy, serializeCommunicationIdentifier, } from "@azure/communication-common";
import { randomUUID } from "@azure/core-util";
/**
 * CallMedia class represents call media related APIs.
 */
export class CallMedia {
    constructor(callConnectionId, endpoint, credential, options) {
        this.callAutomationApiClient = new CallAutomationApiClient(endpoint, options);
        const authPolicy = createCommunicationAuthPolicy(credential);
        this.callAutomationApiClient.pipeline.addPolicy(authPolicy);
        this.callConnectionId = callConnectionId;
        this.callMedia = new CallMediaImpl(this.callAutomationApiClient);
    }
    createPlaySourceInternal(playSource) {
        if (playSource.kind === "fileSource") {
            const fileSource = {
                uri: playSource.url,
            };
            return {
                kind: KnownPlaySourceType.File,
                file: fileSource,
                playSourceCacheId: playSource.playsourcacheid,
            };
        }
        else if (playSource.kind === "textSource") {
            const textSource = {
                text: playSource.text,
                sourceLocale: playSource.sourceLocale,
                voiceKind: playSource.voiceKind,
                voiceName: playSource.voiceName,
                customVoiceEndpointId: playSource.customVoiceEndpointId,
            };
            return {
                kind: KnownPlaySourceType.Text,
                text: textSource,
                playSourceCacheId: playSource.playsourcacheid,
            };
        }
        else if (playSource.kind === "ssmlSource") {
            const ssmlSource = {
                ssmlText: playSource.ssmlText,
                customVoiceEndpointId: playSource.customVoiceEndpointId,
            };
            return {
                kind: KnownPlaySourceType.Ssml,
                ssml: ssmlSource,
                playSourceCacheId: playSource.playsourcacheid,
            };
        }
        throw new Error("Invalid play source");
    }
    /**
     * Play audio to a specific participant.
     *
     * @param playSources - A PlaySource representing the sources to play. Currently only single play source per request is supported.
     * @param playTo - The targets to play to.
     * @param options - Additional attributes for play.
     */
    async play(playSources, playTo, options = { loop: false }) {
        const playRequest = {
            playSources: playSources.map((source) => this.createPlaySourceInternal(source)),
            playTo: playTo.map((identifier) => serializeCommunicationIdentifier(identifier)),
            playOptions: {
                loop: false,
            },
            operationContext: options.operationContext,
            operationCallbackUri: options.operationCallbackUrl,
        };
        if (options.loop !== undefined) {
            playRequest.playOptions = playRequest.playOptions || { loop: false }; // Ensure playOptions is defined
            playRequest.playOptions.loop = options.loop;
        }
        return this.callMedia.play(this.callConnectionId, playRequest, options);
    }
    /**
     * Play to all participants.
     *
     * @param playSources - A PlaySource representing the sources to play. Currently only single play source per request is supported.
     * @param options - Additional attributes for play.
     */
    async playToAll(playSources, options = { loop: false }) {
        const playRequest = {
            playSources: playSources.map((source) => this.createPlaySourceInternal(source)),
            playTo: [],
            playOptions: {
                loop: false,
            },
            interruptCallMediaOperation: options.interruptCallMediaOperation !== undefined
                ? options.interruptCallMediaOperation
                : false,
            operationContext: options.operationContext,
            operationCallbackUri: options.operationCallbackUrl,
        };
        if (options.loop !== undefined) {
            playRequest.playOptions = playRequest.playOptions || { loop: false }; // Ensure playOptions is defined
            playRequest.playOptions.loop = options.loop;
        }
        return this.callMedia.play(this.callConnectionId, playRequest, options);
    }
    createRecognizeRequest(targetParticipant, recognizeOptions) {
        if (recognizeOptions.kind === "callMediaRecognizeDtmfOptions") {
            const dtmfOptionsInternal = {
                interToneTimeoutInSeconds: recognizeOptions.interToneTimeoutInSeconds
                    ? recognizeOptions.interToneTimeoutInSeconds
                    : 2,
                maxTonesToCollect: recognizeOptions.maxTonesToCollect,
                stopTones: recognizeOptions.stopDtmfTones,
            };
            const recognizeOptionsInternal = {
                interruptPrompt: recognizeOptions.interruptPrompt,
                initialSilenceTimeoutInSeconds: recognizeOptions.initialSilenceTimeoutInSeconds
                    ? recognizeOptions.initialSilenceTimeoutInSeconds
                    : 5,
                targetParticipant: serializeCommunicationIdentifier(targetParticipant),
                dtmfOptions: dtmfOptionsInternal,
            };
            return {
                recognizeInputType: KnownRecognizeInputType.Dtmf,
                playPrompt: recognizeOptions.playPrompt
                    ? this.createPlaySourceInternal(recognizeOptions.playPrompt)
                    : undefined,
                playPrompts: recognizeOptions.playPrompts !== undefined
                    ? recognizeOptions.playPrompts.map((source) => this.createPlaySourceInternal(source))
                    : undefined,
                interruptCallMediaOperation: recognizeOptions.interruptCallMediaOperation,
                recognizeOptions: recognizeOptionsInternal,
                operationContext: recognizeOptions.operationContext,
                operationCallbackUri: recognizeOptions.operationCallbackUrl,
            };
        }
        else if (recognizeOptions.kind === "callMediaRecognizeChoiceOptions") {
            const recognizeOptionsInternal = {
                interruptPrompt: recognizeOptions.interruptPrompt,
                initialSilenceTimeoutInSeconds: recognizeOptions.initialSilenceTimeoutInSeconds
                    ? recognizeOptions.initialSilenceTimeoutInSeconds
                    : 5,
                targetParticipant: serializeCommunicationIdentifier(targetParticipant),
                speechLanguage: recognizeOptions.speechLanguage,
                speechRecognitionModelEndpointId: recognizeOptions.speechRecognitionModelEndpointId,
                choices: recognizeOptions.choices,
            };
            return {
                recognizeInputType: KnownRecognizeInputType.Choices,
                playPrompt: recognizeOptions.playPrompt
                    ? this.createPlaySourceInternal(recognizeOptions.playPrompt)
                    : undefined,
                playPrompts: recognizeOptions.playPrompts !== undefined
                    ? recognizeOptions.playPrompts.map((source) => this.createPlaySourceInternal(source))
                    : undefined,
                interruptCallMediaOperation: recognizeOptions.interruptCallMediaOperation,
                recognizeOptions: recognizeOptionsInternal,
                operationContext: recognizeOptions.operationContext,
                operationCallbackUri: recognizeOptions.operationCallbackUrl,
            };
        }
        else if (recognizeOptions.kind === "callMediaRecognizeSpeechOptions") {
            const speechOptions = {
                endSilenceTimeoutInMs: recognizeOptions.endSilenceTimeoutInSeconds
                    ? recognizeOptions.endSilenceTimeoutInSeconds * 1000
                    : 2000,
            };
            const recognizeOptionsInternal = {
                interruptPrompt: recognizeOptions.interruptPrompt,
                initialSilenceTimeoutInSeconds: recognizeOptions.initialSilenceTimeoutInSeconds
                    ? recognizeOptions.initialSilenceTimeoutInSeconds
                    : 5,
                targetParticipant: serializeCommunicationIdentifier(targetParticipant),
                speechOptions: speechOptions,
                speechLanguage: recognizeOptions.speechLanguage,
                speechRecognitionModelEndpointId: recognizeOptions.speechRecognitionModelEndpointId,
            };
            return {
                recognizeInputType: KnownRecognizeInputType.Speech,
                playPrompt: recognizeOptions.playPrompt
                    ? this.createPlaySourceInternal(recognizeOptions.playPrompt)
                    : undefined,
                playPrompts: recognizeOptions.playPrompts !== undefined
                    ? recognizeOptions.playPrompts.map((source) => this.createPlaySourceInternal(source))
                    : undefined,
                interruptCallMediaOperation: recognizeOptions.interruptCallMediaOperation,
                recognizeOptions: recognizeOptionsInternal,
                operationContext: recognizeOptions.operationContext,
                operationCallbackUri: recognizeOptions.operationCallbackUrl,
            };
        }
        else if (recognizeOptions.kind === "callMediaRecognizeSpeechOrDtmfOptions") {
            const dtmfOptionsInternal = {
                interToneTimeoutInSeconds: recognizeOptions.interToneTimeoutInSeconds
                    ? recognizeOptions.interToneTimeoutInSeconds
                    : 2,
                maxTonesToCollect: recognizeOptions.maxTonesToCollect,
                stopTones: recognizeOptions.stopDtmfTones,
            };
            const speechOptions = {
                endSilenceTimeoutInMs: recognizeOptions.endSilenceTimeoutInSeconds
                    ? recognizeOptions.endSilenceTimeoutInSeconds * 1000
                    : 2000,
            };
            const recognizeOptionsInternal = {
                interruptPrompt: recognizeOptions.interruptPrompt,
                initialSilenceTimeoutInSeconds: recognizeOptions.initialSilenceTimeoutInSeconds
                    ? recognizeOptions.initialSilenceTimeoutInSeconds
                    : 5,
                targetParticipant: serializeCommunicationIdentifier(targetParticipant),
                speechOptions: speechOptions,
                dtmfOptions: dtmfOptionsInternal,
                speechRecognitionModelEndpointId: recognizeOptions.speechRecognitionModelEndpointId,
            };
            return {
                recognizeInputType: KnownRecognizeInputType.SpeechOrDtmf,
                playPrompt: recognizeOptions.playPrompt
                    ? this.createPlaySourceInternal(recognizeOptions.playPrompt)
                    : undefined,
                playPrompts: recognizeOptions.playPrompts !== undefined
                    ? recognizeOptions.playPrompts.map((source) => this.createPlaySourceInternal(source))
                    : undefined,
                interruptCallMediaOperation: recognizeOptions.interruptCallMediaOperation,
                recognizeOptions: recognizeOptionsInternal,
                operationContext: recognizeOptions.operationContext,
                operationCallbackUri: recognizeOptions.operationCallbackUrl,
            };
        }
        throw new Error("Invalid recognizeOptions");
    }
    async startRecognizing(targetParticipant, maxTonesOrOptions, options) {
        if (typeof maxTonesOrOptions === "number" && options) {
            // Old function signature logic
            console.warn("Deprecated function signature used. Please use the new signature with targetParticipant and options params instead, and set maxTonesToCollect in options.");
            options.maxTonesToCollect = maxTonesOrOptions;
            return this.callMedia.recognize(this.callConnectionId, this.createRecognizeRequest(targetParticipant, options), {});
        }
        else if (typeof maxTonesOrOptions !== "number" && !options) {
            // New function signature logic
            return this.callMedia.recognize(this.callConnectionId, this.createRecognizeRequest(targetParticipant, maxTonesOrOptions), {});
        }
        throw new Error("Invalid params");
    }
    /**
     * Cancels all the queued media operations.
     */
    async cancelAllOperations() {
        return this.callMedia.cancelAllMediaOperations(this.callConnectionId, {});
    }
    /**
     * Start continuous Dtmf recognition by subscribing to tones.
     * @param targetParticipant - Target participant.
     * @param options - Additional attributes for continuous Dtmf recognition.
     * */
    async startContinuousDtmfRecognition(targetParticipant, options = {}) {
        const continuousDtmfRecognitionRequest = {
            targetParticipant: serializeCommunicationIdentifier(targetParticipant),
            operationContext: options.operationContext,
        };
        return this.callMedia.startContinuousDtmfRecognition(this.callConnectionId, continuousDtmfRecognitionRequest, {});
    }
    /**
     * Stop continuous Dtmf recognition by unsubscribing to tones.
     * @param targetParticipant - Target participant.
     * @param options - Additional attributes for continuous Dtmf recognition.
     * */
    async stopContinuousDtmfRecognition(targetParticipant, options = {}) {
        const continuousDtmfRecognitionRequest = {
            targetParticipant: serializeCommunicationIdentifier(targetParticipant),
            operationContext: options.operationContext,
            operationCallbackUri: options.operationCallbackUrl,
        };
        return this.callMedia.stopContinuousDtmfRecognition(this.callConnectionId, continuousDtmfRecognitionRequest, {});
    }
    /**
     * Send Dtmf tones.
     * @param tones - List of tones to be sent to target participant.
     * @param targetParticipant - Target participant.
     * @param options - Additional attributes for send Dtmf tones.
     * */
    async sendDtmfTones(tones, targetParticipant, options = {}) {
        const sendDtmfTonesRequest = {
            tones: tones,
            targetParticipant: serializeCommunicationIdentifier(targetParticipant),
            operationContext: options.operationContext,
            operationCallbackUri: options.operationCallbackUrl,
        };
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: randomUUID() });
        const result = await this.callMedia.sendDtmfTones(this.callConnectionId, sendDtmfTonesRequest, optionsInternal);
        const sendDtmfTonesResult = Object.assign({}, result);
        return sendDtmfTonesResult;
    }
    /**
     * Put participant on hold while playing audio.
     *
     * @param targetParticipant - The targets to play to.
     * @param options - Additional attributes for hold participant.
     */
    async hold(targetParticipant, options = {}) {
        const holdRequest = {
            targetParticipant: serializeCommunicationIdentifier(targetParticipant),
            playSourceInfo: options.playSource !== undefined
                ? this.createPlaySourceInternal(options.playSource)
                : undefined,
            operationContext: options.operationContext !== undefined ? options.operationContext : undefined,
            operationCallbackUri: options.operationCallbackUrl !== undefined ? options.operationCallbackUrl : undefined,
        };
        return this.callMedia.hold(this.callConnectionId, holdRequest);
    }
    /**
     * Remove participant from hold.
     *
     * @param targetParticipant - The targets to play to.
     * @param options - Additional attributes for unhold participant.
     */
    async unhold(targetParticipant, options = {}) {
        const unholdRequest = {
            targetParticipant: serializeCommunicationIdentifier(targetParticipant),
            operationContext: options.operationContext !== undefined ? options.operationContext : undefined,
        };
        return this.callMedia.unhold(this.callConnectionId, unholdRequest);
    }
}
//# sourceMappingURL=callMedia.js.map