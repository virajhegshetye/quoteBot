// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { __asyncValues, __rest } from "tslib";
import { createCommunicationAuthPolicy, } from "@azure/communication-common";
import { CallMedia } from "./callMedia.js";
import { CallAutomationApiClient, } from "./generated/src/index.js";
import { CallConnectionImpl } from "./generated/src/operations/index.js";
import { callParticipantConverter, communicationIdentifierConverter, communicationIdentifierModelConverter, communicationUserIdentifierConverter, phoneNumberIdentifierConverter, PhoneNumberIdentifierModelConverter, } from "./utli/converters.js";
import { randomUUID } from "@azure/core-util";
/**
 * CallConnection class represents call connection based APIs.
 */
export class CallConnection {
    constructor(callConnectionId, endpoint, credential, options) {
        this.callAutomationApiClient = new CallAutomationApiClient(endpoint, options);
        const authPolicy = createCommunicationAuthPolicy(credential);
        this.callAutomationApiClient.pipeline.addPolicy(authPolicy);
        this.callConnectionId = callConnectionId;
        this.callConnection = new CallConnectionImpl(this.callAutomationApiClient);
        this.endpoint = endpoint;
        this.credential = credential;
        this.callAutomationApiClientOptions = options;
    }
    /**
     * Initializes a new instance of CallMedia.
     */
    getCallMedia() {
        return new CallMedia(this.callConnectionId, this.endpoint, this.credential, this.callAutomationApiClientOptions);
    }
    /**
     * Get call connection properties of the call
     */
    async getCallConnectionProperties(options = {}) {
        const _a = await this.callConnection.getCall(this.callConnectionId, options), { targets, sourceCallerIdNumber, answeredBy, source, answeredFor } = _a, result = __rest(_a, ["targets", "sourceCallerIdNumber", "answeredBy", "source", "answeredFor"]);
        const callConnectionProperties = Object.assign(Object.assign({}, result), { source: source ? communicationIdentifierConverter(source) : undefined, answeredby: communicationUserIdentifierConverter(answeredBy), answeredFor: answeredFor ? phoneNumberIdentifierConverter(answeredFor) : undefined, targetParticipants: targets === null || targets === void 0 ? void 0 : targets.map((target) => communicationIdentifierConverter(target)), sourceCallerIdNumber: sourceCallerIdNumber
                ? phoneNumberIdentifierConverter(sourceCallerIdNumber)
                : undefined });
        return callConnectionProperties;
    }
    /**
     * Hang up the call for itself or terminate the whole call.
     *
     * @param isForEveryOne - Determine if every one in the call would be hung up or not.
     */
    async hangUp(isForEveryone, options = {}) {
        if (isForEveryone) {
            const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: randomUUID() });
            await this.callConnection.terminateCall(this.callConnectionId, optionsInternal);
        }
        else {
            await this.callConnection.hangupCall(this.callConnectionId, options);
        }
        return;
    }
    /**
     * Get a participant from the call
     *
     * @param targetParticipant - The communication identifier of requested participant.
     */
    async getParticipant(targetParticipant, options = {}) {
        let rawId = communicationIdentifierModelConverter(targetParticipant).rawId;
        rawId = rawId === undefined ? "" : rawId;
        const result = await this.callConnection.getParticipant(this.callConnectionId, rawId, options);
        const callParticipant = {
            identifier: result.identifier
                ? communicationIdentifierConverter(result.identifier)
                : undefined,
            isMuted: result.isMuted,
            isOnHold: result.isOnHold,
        };
        return callParticipant;
    }
    /**
     * Get all participants from the call
     */
    async listParticipants(options = {}) {
        var _a, e_1, _b, _c;
        const result = this.callConnection.listParticipants(this.callConnectionId, options);
        const participants = [];
        const pages = result === null || result === void 0 ? void 0 : result.byPage();
        try {
            for (var _d = true, pages_1 = __asyncValues(pages), pages_1_1; pages_1_1 = await pages_1.next(), _a = pages_1_1.done, !_a; _d = true) {
                _c = pages_1_1.value;
                _d = false;
                const page = _c;
                for (const participant of page) {
                    participants.push(callParticipantConverter(participant));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = pages_1.return)) await _b.call(pages_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        const listParticipantResponse = Object.assign(Object.assign({}, result), { values: participants });
        return listParticipantResponse;
    }
    createCustomCallingContextInternal(customCallingContext) {
        const sipHeaders = {};
        const voipHeaders = {};
        if (customCallingContext) {
            for (const header of customCallingContext) {
                if (header.kind === "sipuui") {
                    sipHeaders[`User-To-User`] = header.value;
                }
                else if (header.kind === "sipx") {
                    sipHeaders[`X-MS-Custom-${header.key}`] = header.value;
                }
                else if (header.kind === "voip") {
                    voipHeaders[`${header.key}`] = header.value;
                }
            }
        }
        return { sipHeaders: sipHeaders, voipHeaders: voipHeaders };
    }
    /**
     * Add a participant to the call
     *
     * @param participant - The participant is going to be added.
     */
    async addParticipant(targetParticipant, options = {}) {
        var _a, _b;
        const addParticipantRequest = {
            participantToAdd: communicationIdentifierModelConverter(targetParticipant.targetParticipant),
            sourceCallerIdNumber: PhoneNumberIdentifierModelConverter(targetParticipant.sourceCallIdNumber),
            sourceDisplayName: targetParticipant.sourceDisplayName,
            invitationTimeoutInSeconds: options.invitationTimeoutInSeconds,
            operationContext: options.operationContext,
            operationCallbackUri: options.operationCallbackUrl,
            customCallingContext: this.createCustomCallingContextInternal(targetParticipant.customCallingContext),
        };
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: randomUUID() });
        const result = await this.callConnection.addParticipant(this.callConnectionId, addParticipantRequest, optionsInternal);
        const addParticipantsResult = Object.assign(Object.assign({}, result), { participant: Object.assign(Object.assign({}, result.participant), { identifier: ((_a = result.participant) === null || _a === void 0 ? void 0 : _a.identifier)
                    ? communicationIdentifierConverter((_b = result.participant) === null || _b === void 0 ? void 0 : _b.identifier)
                    : undefined }) });
        return addParticipantsResult;
    }
    /**
     * Transfer the call to a target participant
     *
     * @param targetParticipant - The target to be transferred to.
     */
    async transferCallToParticipant(targetParticipant, options = {}) {
        const transferToParticipantRequest = {
            targetParticipant: communicationIdentifierModelConverter(targetParticipant),
            operationContext: options.operationContext,
            operationCallbackUri: options.operationCallbackUrl,
            transferee: options.transferee && communicationIdentifierModelConverter(options.transferee),
            customCallingContext: this.createCustomCallingContextInternal(options.customCallingContext),
            sourceCallerIdNumber: PhoneNumberIdentifierModelConverter(options.sourceCallIdNumber),
        };
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: randomUUID() });
        const result = await this.callConnection.transferToParticipant(this.callConnectionId, transferToParticipantRequest, optionsInternal);
        const transferCallResult = Object.assign({}, result);
        return transferCallResult;
    }
    /**
     * Remove a participant from the call
     *
     * @param participant - The participant is going to be removed from the call.
     */
    async removeParticipant(participant, options = {}) {
        const removeParticipantRequest = {
            participantToRemove: communicationIdentifierModelConverter(participant),
            operationContext: options.operationContext,
            operationCallbackUri: options.operationCallbackUrl,
        };
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: randomUUID() });
        const result = await this.callConnection.removeParticipant(this.callConnectionId, removeParticipantRequest, optionsInternal);
        const removeParticipantsResult = Object.assign({}, result);
        return removeParticipantsResult;
    }
    /**
     * Mute participant from the call.
     *
     * @param participant - Participant to be muted from the call.
     * @param options - Additional attributes for mute participant.
     */
    async muteParticipant(participant, options = {}) {
        const muteParticipantsRequest = {
            targetParticipants: [communicationIdentifierModelConverter(participant)],
            operationContext: options.operationContext,
        };
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: randomUUID() });
        const result = await this.callConnection.mute(this.callConnectionId, muteParticipantsRequest, optionsInternal);
        const muteParticipantResult = Object.assign({}, result);
        return muteParticipantResult;
    }
    /** Cancel add participant operation.
     *
     * @param invitationId - Invitation ID used to cancel the add participant request.
     * @param options - Additional attributes for cancel add participant operation.
     */
    async cancelAddParticipantOperation(invitationId, options = {}) {
        const { operationContext, operationCallbackUrl: operationCallbackUri } = options, operationOptions = __rest(options, ["operationContext", "operationCallbackUrl"]);
        const cancelAddParticipantRequest = {
            invitationId,
            operationContext: options.operationContext,
            operationCallbackUri,
        };
        const optionsInternal = Object.assign(Object.assign({}, operationOptions), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: randomUUID() });
        const result = await this.callConnection.cancelAddParticipant(this.callConnectionId, cancelAddParticipantRequest, optionsInternal);
        const cancelAddParticipantResult = Object.assign({}, result);
        return cancelAddParticipantResult;
    }
}
//# sourceMappingURL=callConnection.js.map